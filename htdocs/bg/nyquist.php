<?php BoxTop("Nyquist"); ?>

<p>
<b>Част 1: Въведение в Nyquist и програмирането на Lisp.</b><br>
<?php print "<a href=nyquist2.php?$langLinkStr>";
?>Part 2: Програмиране на Nyquist.</a><br>
<?php print "<a href=nyquist3.php?$langLinkStr>";
?>Part 3: Създаване на приставки с Nyquist.</a><br>
</p>

<p>
От версия 1.1.1 нататък Audacity ви позволява да пишете собствени
приставки за ефекти на езика Nyquist. За разлика от приставките
VST и LADSPA, тези на Nyquist могат да се създават с помощта само
на обикновен текстов редактор и няма нужда да се компилират.
</p>

<p>
Nyquist е създаден от Роджър Даненберг
(<a target=_top href="http://www-2.cs.cmu.edu/~rbd/">Roger B. Dannenberg</a>)
и е замислен като завършен програмен език за синтез и анализ на звук,
с поддръжка на MIDI, запис и възпроизвеждане на звук, профилиране,
трасиране и др.  Audacity използва подмножество от функционалността му,
позволявайки само обработка на звукови данни чрез прости функции на
Nyquist.  Не се поддържа трасиране (debugging), така че ако се опитвате
да създадете сложна приставка с Nyquist, може би ще ви е по-лесно да
се сдобиете с пълна версия на езика и да разработвате с нея, като
едва накрая преобразувате резултата в приставка за Audacity.
Nyquist е достъпен на страниците на проекта Carnegie Mellon
University Computer Music Project:
<ul>
<a target=_top href="http://www-2.cs.cmu.edu/~music/music.software.html"
>CMU Computer Music Project Software</a> - 
от тук можете да свалите пълния Nyquist.</a>
<br>
<a target=_top href="http://www-2.cs.cmu.edu/~rbd/doc/nyquist/root.html"
>Пълно ръководство по Nyquist от CMU</a>
</ul>
</p>

<p>
Забележете, че няма нужда да сваляте Nyquist, за да пишете прости
приставки за Audacity.  Всички указания, които са ви нужни, се намират
по-долу.
</p>

<p><b>Lisp</b></p>

<p>
Nyquist е базиран върху <i>Lisp</i>.  Ако сте програмирали на Lisp,
може да прочетете този раздел само по диагонал или направо да преминете към 
<?php print "<a href=nyquist2.php?$langLinkStr>";
?><b>следващата страница</b></a>.
В противен случай, следва изключително съкратено въведение в Lisp.
</p>

<p>
В Lisp (а следователно и в Nyquist) всичко се представя чрез S-изрази,
които представляват списъци от елементи, разделени с интервали и оградени
със скоби.  Името на функцията е винаги първи елемент на S-израза, а
останалите елементи са аргументите на тази функция. Ето един прост пример:
</p>

<pre>
  (setf area (* 3.14159 (expt radius 2)))
</pre>

<p>
Да анализираме горния пример.  Най-външният S-израз има три члена.
Първият, <tt>setf</tt>, е името на функцията (от set field).  Чрез
тази функция се присвоява стойност на променлива (има и други подобни
функции, например <tt>set</tt> и <tt>setq</tt>, но <tt>setf</tt> е
най-мощната, затова ще използване нея за пример).  След <tt>setf</tt>
следва <tt>area</tt>, което е името на променливата, приемаща
стойността.  По-нататък следва стойността за присвояване, която в
този случай е друг S-израз.
</p>

<p>
В Lisp няма специални оператори за аритметичните действия - те са
обикновени функции като всички останали, с префиксен запис, при който
името на функцията или оператора предшества аргументите.  Например,
за произведението на 3 и 7 вместо 3 * 7 на Lisp ще напишете (* 3 7).
В Nyquist функцията <tt>expt</tt> (експонента) повдига първия аргумент
на степен втория.  Например, <tt>(* 3.14159 (expt radius 2))</tt>
означава 3.14159 по квадрата на <tt>radius</tt>, т.е. формулата за
лице на кръг.
</p>

<p>
Вместо всеки път да въвеждате целия израз, нека дефинираме функция за
лице на кръг, която може да се извиква всеки път, когато се нуждаете
от нея:
</p>

<pre>
  (defun circlearea (radius) (* 3.14159 (expt radius 2)))
</pre>

<p>
Функцията <tt>defun</tt> служи за дефиниране на нова функция.  Първият
аргумент е името на новата функция, в случая - <tt>circlearea</tt>.
Вторият аргумент е списъкът с аргументи на дефинираната функция - това
е един от малкото случаи на S-израз, който не се тълкува като обръщение
към функция.  Последният израз е стойността на функцията.  Сега, ако искаме
да изчислим лицето на кръг с радиус <tt>r</tt>, трябва да напишем:
</p>

<pre>
  (setf area (circlearea r))
</pre>

<p>
S-изразът е просто начин на представяне на списък.  В Lisp на практика 
всичко се представя чрез списъци (името LISP идва от LISt Processing -
обработка на списъци), така че е полезно да знаете как се работи със списъци.
Да започнем с присвояване на списък от стойности на променлива.  Не можете
просто да напишете това:
</p>

<pre>
  (setf mylist (1 2 3 4 5))  <font color=#cc0000><--  грешка!</font>
</pre>

<p>
Причината е, че когато интерпретаторът на Nyquist срещне S-израз, той се
опитва да го изчисли като функция, освен ако няма изрично указание за
обратното.  Тъй като няма функция с име "1", която да приема аргументи
<tt>(2 3 4 5)</tt>, горният пример ще предизвика съобщение за грешка.
За да укажете, че даден S-израз трябва да се вземе буквално, а не да се
пресмята като функция, трябва да го "цитирате" (quote).  В Nyquist това
става чрез поставяне на единична кавичка пред израза, както по-долу:
</p>

<pre>
  (setf mylist '(1 2 3 4 5))
</pre>

<p>
В Nyquist има функция <tt>list</tt> за конструиране на списъци - това е
полезно, ако някои елементи на списъка са функции:
</p>

<pre>
  (setf mylist (list 1 2 3 4 (sqrt 25)))
</pre>

<p>
За извличане на елементи от списък могат да се използват функциите
<tt>first</tt> и <tt>rest</tt> (по традиция имената им са съответно 
<tt>car</tt> и <tt>cdr</tt>, но <tt>first</tt> и <tt>rest</tt> се
помнят по-лесно - Nyquist поддържа и двата варианта).  Резултатът от
<tt>(first mylist)</tt> е 1, а този от <tt>(rest mylist)</tt> е списъкът
<tt>(2 3 4 5)</tt>.  Така вторият елемент на списъка ще бъде
<tt>(first (rest mylist))</tt>.
</p>

<p>
<b>Справочник за функциите на Lisp</b>
</p>

<p>
Следва списък на основните функции в Lisp, които може би ще са ви нужни.
</p>

<table border=0>
<tr><td align=center><i>Математически операции</i></td><td></td></tr>
<tr><td><tt>(+ a b)</tt></td><td>събиране</td></tr>
<tr><td><tt>(- a b)</tt></td><td>изваждане</td></tr>
<tr><td><tt>(* a b)</tt></td><td>умножение</td></tr>
<tr><td><tt>(/ a b)</tt></td><td>деление</td></tr>
<tr><td><tt>(truncate a b)</tt></td><td>закръгляне надолу до цяло число</td></tr>
<tr><td><tt>(float a b)</tt></td><td>цяло число --&gt; число с плаваща запетая</td></tr>
<tr><td><tt>(rem a b c ...)</tt></td><td>остатък</td></tr>
<tr><td><tt>(min a b c ...)</tt></td><td>минимум</td></tr>
<tr><td><tt>(max a b c ...)</tt></td><td>максимум</td></tr>
<tr><td><tt>(abs a)</tt></td><td>абсолютна стойност</td></tr>
<tr><td><tt>(random n)</tt></td><td>случайно цяло число между 1 и n - 1</td></tr>
<tr><td><tt>(sin a b)</tt></td><td>синус</td></tr>
<tr><td><tt>(cos a b)</tt></td><td>косинус</td></tr>
<tr><td><tt>(tan a b)</tt></td><td>тангенс</td></tr>
<tr><td><tt>(expt a b)</tt></td><td>експонента (a на степен b)</td></tr>
<tr><td><tt>(sqrt a b)</tt></td><td>квадратен корен</td></tr>
<tr><td><tt>(< a b)</tt></td><td>проверка дали a е по-малко от b</td></tr>
<tr><td><tt>(<= a b)</tt></td><td>проверка дали a е по-малко или равно на b</td></tr>
<tr><td><tt>(> a b)</tt></td><td>проверка дали a е по-голямо от b</td></tr>
<tr><td><tt>(>= a b)</tt></td><td>проверка дали a е по-голямо или равно на b</td></tr>
<tr><td><tt>(= a b)</tt></td><td>проверка за равенство</td></tr>
<tr><td><tt>(/= a b)</tt></td><td>проверка за неравенство</td></tr>
<tr><td align=center><i>Функции за списъци</i></td><td></td></tr>
<tr><td><tt>(first l)</tt></td><td>първи елемент на списък (car)</td></tr>
<tr><td><tt>(rest l)</tt></td><td>остатък от списък (cdr)</td></tr>
<tr><td><tt>(reverse l)</tt></td><td>обръщане на списък</td></tr>
<tr><td><tt>(list a b ...)</tt></td><td>конструиране на списък</td></tr>
<tr><td><tt>(append l1 l2)</tt></td><td>слепване на списъци</td></tr>
<tr><td><tt>(length l)</tt></td><td>дължина на списък</td></tr>
<tr><td><tt>(maplist function l)</tt></td><td>прилагане на функция върху всеки от елементите на списък</td></tr>
<tr><td align=center><i>Управление</i></td><td></td></tr>
<tr><td><tt>(if expr expr1 expr2)</tt></td><td>ако expr е истина, се изчислява expr1, иначе се изчислява expr2</td></tr> 
</table>

<p>
За пълен списък на функциите в Lisp / Nyquist вижте
<a target=_top href="http://www-2.cs.cmu.edu/~rbd/doc/nyquist/root.html">Ръководството по Nyquist</a>.
</p>

<p>
<b>Бележка: интерпретаторът на Nyquist не различава редовни и главни букви в символите
(например имена на променливи и функции).  Вътрешно всички те се преобразуват в главни букви.</b>
</p>

<p>
<?php print "<a href=nyquist2.php?$langLinkStr>";
?><b>Следваща страница: програмиране на Nyquist</b></a>
</p>

<?php BoxBottom(); ?>

